<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>404 - 页面未找到</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background-color: #000;
            color: #0f0;
            overflow: hidden;
            position: relative;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #matrix-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 1200px;
            padding: 20px;
            position: relative;
            z-index: 1;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            margin: 20px;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.2);
        }

        h1 {
            font-size: clamp(2.5rem, 8vw, 4rem);
            margin-bottom: 15px;
            text-shadow: 0 0 10px #0f0;
            animation: glow 2s infinite alternate;
            letter-spacing: 0.2em;
            width: 100%;
            text-align: center;
        }

        @keyframes glow {
            from { text-shadow: 0 0 5px #0f0, 0 0 10px #0f0; }
            to { text-shadow: 0 0 10px #0f0, 0 0 20px #0f0, 0 0 30px #0f0; }
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 15px;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
        }

        p {
            font-size: clamp(1rem, 2.5vw, 1.2rem);
            margin-bottom: 15px;
            text-align: center;
            max-width: 600px;
        }

        .game-wrapper {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
            gap: 20px;
            width: 100%;
        }

        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #tetris {
            border: 2px solid #0f0;
            background-color: rgba(0, 0, 0, 0.9);
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
            max-width: 100%;
            height: auto;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 300px;
            margin: 10px auto;
            font-size: clamp(0.9rem, 2vw, 1.1rem);
        }

        .score, .level {
            background-color: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 5px;
            border: 1px solid #0f0;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
            flex: 1;
            text-align: center;
            margin: 0 5px;
        }

        .controls {
            margin-top: 15px;
            font-size: clamp(0.8rem, 2vw, 0.9rem);
            text-align: center;
            color: #0f0;
            width: 100%;
        }

        .back-link {
            display: inline-block;
            color: #0f0;
            text-decoration: none;
            margin-top: 20px;
            padding: 10px 20px;
            border: 1px solid #0f0;
            border-radius: 5px;
            transition: all 0.3s;
            font-size: clamp(0.9rem, 2.5vw, 1rem);
        }

        .back-link:hover {
            background-color: rgba(0, 255, 0, 0.1);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            text-shadow: 0 0 5px #0f0;
        }

        @media (max-width: 768px) {
            .game-wrapper {
                flex-direction: column;
            }

            .game-info {
                flex-direction: column;
                gap: 10px;
            }

            .score, .level {
                width: 100%;
                margin: 0;
            }
        }
    </style>
</head>
<body>
    <canvas id="matrix-bg"></canvas>

    <div class="container">
        <h1>404</h1>
        <p>页面未找到，但你可以玩会儿俄罗斯方块打发时间！</p>

        <div class="game-container">
            <div class="game-wrapper">
                <div class="game-area">
                    <div class="game-info">
                        <div class="score">得分: <span id="score">0</span></div>
                        <div class="level">等级: <span id="level">1</span></div>
                    </div>

                    <canvas id="tetris" width="300" height="600"></canvas>

                    <div class="controls">
                        <p>← → 移动 | ↑ 旋转 | ↓ 加速下落</p>
                    </div>
                </div>
            </div>
        </div>

        <a href="/" class="back-link">返回首页</a>
    </div>

    <script>
        // 黑客帝国代码雨背景
        const matrixCanvas = document.getElementById('matrix-bg');
        const matrixCtx = matrixCanvas.getContext('2d');

        function resizeMatrixCanvas() {
            matrixCanvas.width = window.innerWidth;
            matrixCanvas.height = window.innerHeight;
        }

        resizeMatrixCanvas();
        window.addEventListener('resize', resizeMatrixCanvas);

        const matrix = "ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789@#$%^&*()*&^%+-/~{[|`]}";
        const matrixArray = matrix.split("");

        const fontSize = 10;
        const columns = matrixCanvas.width / fontSize;

        const drops = [];
        for(let x = 0; x < columns; x++) {
            drops[x] = 1;
        }

        function drawMatrix() {
            matrixCtx.fillStyle = 'rgba(0, 0, 0, 0.04)';
            matrixCtx.fillRect(0, 0, matrixCanvas.width, matrixCanvas.height);

            matrixCtx.fillStyle = '#0F0';
            matrixCtx.font = fontSize + 'px monospace';

            for(let i = 0; i < drops.length; i++) {
                const text = matrixArray[Math.floor(Math.random() * matrixArray.length)];
                matrixCtx.fillText(text, i * fontSize, drops[i] * fontSize);

                if(drops[i] * fontSize > matrixCanvas.height && Math.random() > 0.975) {
                    drops[i] = 0;
                }
                drops[i]++;
            }
        }

        setInterval(drawMatrix, 35);

        // 俄罗斯方块游戏代码
        const canvas = document.getElementById('tetris');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('level');

        const ROW = 20;
        const COL = 10;
        const BLOCK_SIZE = 30;

        let score = 0;
        let level = 1;
        let gameInterval;

        // 方块形状
        const SHAPES = [
            [[1, 1, 1, 1]], // I
            [[1, 1], [1, 1]], // O
            [[1, 1, 1], [0, 1, 0]], // T
            [[1, 1, 1], [1, 0, 0]], // L
            [[1, 1, 1], [0, 0, 1]], // J
            [[0, 1, 1], [1, 1, 0]], // S
            [[1, 1, 0], [0, 1, 1]]  // Z
        ];

        const COLORS = ['#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', '#FF8E0D', '#FFE138', '#3877FF'];

        let board = Array(ROW).fill().map(() => Array(COL).fill(0));
        let currentPiece = null;
        let currentX = 0;
        let currentY = 0;
        let currentColor = 0;

        // 创建新方块
        function newPiece() {
            const id = Math.floor(Math.random() * SHAPES.length);
            currentPiece = SHAPES[id];
            currentX = Math.floor((COL - currentPiece[0].length) / 2);
            currentY = 0;
            currentColor = id;

            // 游戏结束检查
            if (collision()) {
                gameOver();
            }
        }

        // 碰撞检测
        function collision() {
            for (let y = 0; y < currentPiece.length; y++) {
                for (let x = 0; x < currentPiece[y].length; x++) {
                    if (currentPiece[y][x]) {
                        const boardX = currentX + x;
                        const boardY = currentY + y;

                        if (boardX < 0 || boardX >= COL || boardY >= ROW) {
                            return true;
                        }

                        if (boardY >= 0 && board[boardY][boardX]) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // 旋转方块
        function rotate() {
            const rotated = currentPiece[0].map((_, i) =>
                currentPiece.map(row => row[i]).reverse()
            );

            const previousPiece = currentPiece;
            currentPiece = rotated;

            if (collision()) {
                currentPiece = previousPiece;
            }
        }

        // 固定方块到游戏板
        function merge() {
            for (let y = 0; y < currentPiece.length; y++) {
                for (let x = 0; x < currentPiece[y].length; x++) {
                    if (currentPiece[y][x]) {
                        if (currentY + y >= 0) {
                            board[currentY + y][currentX + x] = currentColor + 1;
                        }
                    }
                }
            }
        }

        // 清除完整的行
        function clearLines() {
            let linesCleared = 0;

            for (let y = ROW - 1; y >= 0; y--) {
                if (board[y].every(cell => cell !== 0)) {
                    board.splice(y, 1);
                    board.unshift(Array(COL).fill(0));
                    linesCleared++;
                    y++;
                }
            }

            if (linesCleared > 0) {
                score += linesCleared * 100 * level;
                level = Math.floor(score / 1000) + 1;
                scoreElement.textContent = score;
                levelElement.textContent = level;

                // 重新设置游戏速度
                clearInterval(gameInterval);
                gameInterval = setInterval(gameLoop, 1000 / level);
            }
        }

        // 绘制方块
        function drawBlock(x, y, color) {
            ctx.fillStyle = COLORS[color];
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            ctx.strokeStyle = '#0f0';
            ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);

            // 添加内部高光效果
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(x * BLOCK_SIZE + 2, y * BLOCK_SIZE + 2, BLOCK_SIZE - 4, 4);
            ctx.fillRect(x * BLOCK_SIZE + 2, y * BLOCK_SIZE + 2, 4, BLOCK_SIZE - 4);
        }

        // 绘制游戏板
        function draw() {
            // 清除画布
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 绘制已固定的方块
            for (let y = 0; y < ROW; y++) {
                for (let x = 0; x < COL; x++) {
                    if (board[y][x]) {
                        drawBlock(x, y, board[y][x] - 1);
                    }
                }
            }

            // 绘制当前方块
            if (currentPiece) {
                for (let y = 0; y < currentPiece.length; y++) {
                    for (let x = 0; x < currentPiece[y].length; x++) {
                        if (currentPiece[y][x]) {
                            drawBlock(currentX + x, currentY + y, currentColor);
                        }
                    }
                }
            }
        }

        // 游戏结束
        function gameOver() {
            clearInterval(gameInterval);
            const finalScore = `游戏结束！得分: ${score}`;

            // 创建自定义对话框
            const modal = document.createElement('div');
            modal.style.position = 'fixed';
            modal.style.top = '50%';
            modal.style.left = '50%';
            modal.style.transform = 'translate(-50%, -50%)';
            modal.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
            modal.style.border = '2px solid #0f0';
            modal.style.padding = '20px';
            modal.style.borderRadius = '10px';
            modal.style.textAlign = 'center';
            modal.style.zIndex = '1000';
            modal.style.boxShadow = '0 0 20px rgba(0, 255, 0, 0.5)';
            modal.style.maxWidth = '90%';
            modal.style.width = '300px';

            const message = document.createElement('p');
            message.textContent = finalScore;
            message.style.color = '#0f0';
            message.style.fontSize = 'clamp(1.2rem, 4vw, 1.5rem)';
            message.style.marginBottom = '20px';

            const restartBtn = document.createElement('button');
            restartBtn.textContent = '重新开始';
            restartBtn.style.backgroundColor = 'transparent';
            restartBtn.style.color = '#0f0';
            restartBtn.style.border = '1px solid #0f0';
            restartBtn.style.padding = '10px 20px';
            restartBtn.style.borderRadius = '5px';
            restartBtn.style.cursor = 'pointer';
            restartBtn.style.fontSize = 'clamp(0.9rem, 2.5vw, 1rem)';
            restartBtn.style.transition = 'all 0.3s';
            restartBtn.style.width = '100%';

            restartBtn.addEventListener('mouseover', () => {
                restartBtn.style.backgroundColor = 'rgba(0, 255, 0, 0.1)';
                restartBtn.style.boxShadow = '0 0 10px rgba(0, 255, 0, 0.5)';
            });

            restartBtn.addEventListener('mouseout', () => {
                restartBtn.style.backgroundColor = 'transparent';
                restartBtn.style.boxShadow = 'none';
            });

            restartBtn.addEventListener('click', () => {
                location.reload();
            });

            modal.appendChild(message);
            modal.appendChild(restartBtn);
            document.body.appendChild(modal);
        }

        // 游戏主循环
        function gameLoop() {
            currentY++;

            if (collision()) {
                currentY--;
                merge();
                clearLines();
                newPiece();
            }

            draw();
        }

        // 键盘控制
        document.addEventListener('keydown', e => {
            if (!currentPiece) return;

            switch (e.key) {
                case 'ArrowLeft':
                    currentX--;
                    if (collision()) currentX++;
                    break;
                case 'ArrowRight':
                    currentX++;
                    if (collision()) currentX--;
                    break;
                case 'ArrowDown':
                    currentY++;
                    if (collision()) {
                        currentY--;
                        merge();
                        clearLines();
                        newPiece();
                    }
                    score++;
                    scoreElement.textContent = score;
                    break;
                case 'ArrowUp':
                    rotate();
                    break;
            }

            draw();
        });

        // 初始化游戏
        function init() {
            newPiece();
            draw();
            gameInterval = setInterval(gameLoop, 1000 / level);
        }

        init();
    </script>
</body>
</html>
